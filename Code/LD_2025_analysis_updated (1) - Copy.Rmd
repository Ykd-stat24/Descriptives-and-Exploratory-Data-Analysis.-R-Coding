---
title: "Location Discrimination Analysis – LD 2025 dataset"
author: "Behavioral phenotyping update"
date: "`r format(Sys.Date())`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center"
)

library(tidyverse)
library(readxl)
library(janitor)
library(stringr)
library(gt)
library(FactoMineR)
library(factoextra)
library(survival)
library(survminer)
library(broom)
```

# Data ingestion and cleaning

```{r load-data}
raw_data <- read_excel(
  file.path("..", "Processed Data", "LDR 2025 data1_processed_withSecondCriterion.xlsx")
) %>%
  clean_names()

trial_cols <- str_subset(names(raw_data), "^trial_analysis_no_correct_\\d+")
stopifnot(length(trial_cols) > 0)

total_trials <- length(trial_cols)
```

The processed export includes one row per animal-day with trial-level summaries. The helper code below derives cohort identifiers ("c1" … "c4") from the animal IDs and recodes strain symbols to human-readable labels.

```{r feature-engineering}
scale_within <- function(x) {
  if (all(is.na(x)) || sum(!is.na(x)) < 2 || sd(x, na.rm = TRUE) == 0) {
    return(rep(0, length(x)))
  }
  as.numeric(scale(x))
}

session_features <- raw_data %>%
  mutate(
    cohort = str_extract(animal_id, "^c\\d+"),
    strain = recode(strain, "+" = "B6", "-" = "C3HxB6"),
    sex = factor(sex, levels = c("M", "F")),
    day = as.integer(day),
    trials_completed = end_summary_trials_completed_1,
    omissions = total_trials - trials_completed,
    omission_rate = omissions / total_trials,
    iti_touch_asym = end_summary_left_iti_touches_1 - end_summary_right_iti_touches_1,
    reward_collection_latency = correct_reward_collection
  ) %>%
  select(
    animal_id, cohort, strain, sex, day, schedule_run_date, second_criterion_count,
    trials_completed, omissions, omission_rate, iti_touch_asym,
    correct_touch_latency, reward_collection_latency, blank_touch_latency
  )

animal_features <- session_features %>%
  group_by(animal_id, cohort, strain, sex) %>%
  summarise(
    days_observed = max(day, na.rm = TRUE),
    omission_rate_mean = mean(omission_rate, na.rm = TRUE),
    omission_rate_sd = sd(omission_rate, na.rm = TRUE),
    iti_touch_asym_mean = mean(iti_touch_asym, na.rm = TRUE),
    iti_touch_asym_sd = sd(iti_touch_asym, na.rm = TRUE),
    touch_latency_mean = mean(correct_touch_latency, na.rm = TRUE),
    touch_latency_iqr = IQR(correct_touch_latency, na.rm = TRUE),
    reward_latency_mean = mean(reward_collection_latency, na.rm = TRUE),
    reward_latency_iqr = IQR(reward_collection_latency, na.rm = TRUE),
    blank_latency_mean = mean(blank_touch_latency, na.rm = TRUE),
    event = any(second_criterion_count > 0, na.rm = TRUE),
    first_criterion_day = ifelse(
      any(second_criterion_count > 0, na.rm = TRUE),
      min(day[second_criterion_count > 0], na.rm = TRUE),
      NA_real_
    ),
    .groups = "drop"
  ) %>%
  mutate(
    omission_rate_sd = replace_na(omission_rate_sd, 0),
    iti_touch_asym_sd = replace_na(iti_touch_asym_sd, 0),
    time_to_criterion = if_else(is.na(first_criterion_day), days_observed, first_criterion_day)
  )
```

# Feature overview

```{r feature-table}
feature_table <- animal_features %>%
  select(
    animal_id, cohort, strain, sex,
    omission_rate_mean, omission_rate_sd,
    iti_touch_asym_mean, iti_touch_asym_sd,
    touch_latency_mean, touch_latency_iqr,
    reward_latency_mean, reward_latency_iqr,
    blank_latency_mean
  ) %>%
  mutate(across(where(is.numeric), round, 2)) %>%
  arrange(cohort, animal_id) %>%
  gt() %>%
  tab_header(
    title = "Engineered behavioral features by animal"
  )

feature_table
```

# Multivariate phenotyping

```{r pca-prep}
feature_cols <- c(
  "omission_rate_mean", "omission_rate_sd",
  "iti_touch_asym_mean", "iti_touch_asym_sd",
  "touch_latency_mean", "touch_latency_iqr",
  "reward_latency_mean", "reward_latency_iqr",
  "blank_latency_mean"
)

scaled_features <- animal_features %>%
  group_by(cohort) %>%
  mutate(across(all_of(feature_cols), scale_within, .names = "scaled_{.col}")) %>%
  ungroup()

pca_matrix <- scaled_features %>%
  select(starts_with("scaled_"))

non_zero_cols <- vapply(
  pca_matrix,
  function(x) {
    if (all(is.na(x))) {
      return(FALSE)
    }
    sd(x, na.rm = TRUE) > 0
  },
  logical(1)
)
pca_matrix <- as.data.frame(pca_matrix[, non_zero_cols, drop = FALSE])

rownames(pca_matrix) <- scaled_features$animal_id

pca_res <- FactoMineR::PCA(pca_matrix, graph = FALSE)

pca_scores <- as_tibble(pca_res$ind$coord, rownames = "animal_id") %>%
  left_join(scaled_features %>% select(animal_id, strain, cohort, sex), by = "animal_id")
```

```{r pca-biplot, fig.height=6, fig.width=8}
fviz_pca_biplot(
  pca_res,
  habillage = scaled_features$strain,
  addEllipses = TRUE,
  repel = TRUE,
  label = "var",
  palette = c("B6" = "#d95f02", "C3HxB6" = "#1b9e77")
) +
  ggtitle("PCA biplot of scaled behavioral features")
```

```{r genotype-loadings}
genotype_pc_summary <- pca_scores %>%
  group_by(strain) %>%
  summarise(
    across(starts_with("Dim"), mean, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(across(starts_with("Dim"), round, 2)) %>%
  gt() %>%
  tab_header(title = "Mean principal component scores by genotype")

genotype_pc_summary
```

```{r clustering}
dist_mat <- dist(pca_matrix)
hc <- hclust(dist_mat, method = "ward.D2")
clusters <- cutree(hc, k = 3)

cluster_assignments <- scaled_features %>%
  mutate(cluster = factor(clusters)) %>%
  select(animal_id, strain, cohort, cluster)
```

```{r dendrogram, fig.height=6, fig.width=6}
fviz_dend(
  hc,
  k = 3,
  rect = TRUE,
  show_labels = TRUE,
  cex = 0.8,
  main = "Hierarchical clustering of behavioral phenotypes"
)
```

```{r cluster-table}
cluster_table <- cluster_assignments %>%
  count(strain, cluster) %>%
  group_by(strain) %>%
  mutate(percentage = scales::percent(n / sum(n))) %>%
  ungroup() %>%
  arrange(strain, cluster) %>%
  gt() %>%
  tab_header(title = "Cluster membership by genotype")

cluster_table
```

# Survival-style time-to-criterion analysis

```{r survival-prep}
survival_df <- session_features %>%
  group_by(animal_id, cohort, strain, sex) %>%
  summarise(
    event_day = ifelse(
      any(second_criterion_count > 0, na.rm = TRUE),
      min(day[second_criterion_count > 0], na.rm = TRUE),
      NA_real_
    ),
    censor_day = max(day, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    time_to_event = if_else(is.na(event_day), censor_day, event_day),
    event = !is.na(event_day)
  )

surv_obj <- Surv(time = survival_df$time_to_event, event = survival_df$event)
km_fit <- survfit(surv_obj ~ strain, data = survival_df)
```

```{r km-plot, fig.height=6, fig.width=8}
km_plot <- ggsurvplot(
  km_fit,
  data = survival_df,
  fun = "event",
  conf.int = TRUE,
  conf.int.alpha = 0.2,
  palette = c("B6" = "#d95f02", "C3HxB6" = "#1b9e77"),
  legend.title = "Genotype",
  legend.labs = levels(factor(survival_df$strain)),
  xlab = "Day",
  ylab = "% meeting second criterion",
  ggtheme = theme_minimal()
)

km_plot
```

```{r survival-tables}
median_table <- surv_median(km_fit) %>%
  as_tibble() %>%
  mutate(across(where(is.numeric), ~ round(.x, 1))) %>%
  gt() %>%
  tab_header(title = "Median time-to-second-criterion by genotype")

cox_mod <- coxph(surv_obj ~ strain, data = survival_df)
cox_table <- tidy(cox_mod, exponentiate = TRUE, conf.int = TRUE) %>%
  mutate(across(c(estimate, conf.low, conf.high), ~ round(.x, 2))) %>%
  gt() %>%
  tab_header(title = "Cox proportional hazards model") %>%
  cols_label(
    term = "Predictor",
    estimate = "Hazard ratio",
    conf.low = "Lower 95% CI",
    conf.high = "Upper 95% CI",
    p.value = "p-value"
  )

median_table
cox_table
```

# Stakeholder summary

The engineered feature set captures omissions, ITI touch asymmetry, and latency variability (IQR-based) alongside reward collection dynamics. PCA and hierarchical clustering highlight composite behavioral phenotypes, while genotype-specific summaries and cluster memberships aid in interpreting cohort-level differences. Kaplan–Meier curves and Cox models extend the familiar survival framework to the new dataset, providing continuity with the prior LD analytical workflow and offering interpretable time-to-second-criterion comparisons.
